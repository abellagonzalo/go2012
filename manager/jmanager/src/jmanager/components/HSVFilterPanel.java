/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * HSVFilterPanel2.java
 *
 * Created on 25-feb-2012, 18:13:47
 */
package jmanager.components;

import java.awt.Transparency;
import java.awt.color.ColorSpace;
import java.awt.image.BufferedImage;
import java.awt.image.ColorModel;
import java.awt.image.ComponentColorModel;
import java.awt.image.DataBuffer;
import java.awt.image.DataBufferByte;
import java.awt.image.Raster;
import java.awt.image.WritableRaster;
import java.util.EventListener;
import java.util.EventObject;
import javax.swing.ImageIcon;
import javax.swing.JPanel;

/**
 * Panel which implements an HSV filter.
 * @author Gonzalo Abella (abellagonzalo@gmail.com)
 */
public class HSVFilterPanel extends JPanel {

    private byte[] circle = null;
    private int imageWidth = 300;
    private int imageHeight = 300;
    private int imageChannels = 3;
    private double[] histogramH = new double[0];
    private double[] histogramS = new double[0];
    private double[] histogramV = new double[0];

    /** Creates new form BeanForm */
    public HSVFilterPanel() {
        initComponents();
        refresh();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        ColorCircleLabel = new javax.swing.JLabel();
        jPanel7 = new javax.swing.JPanel();
        showHistogramCheckBox = new javax.swing.JCheckBox();
        jPanel2 = new javax.swing.JPanel();
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        jPanel3 = new javax.swing.JPanel();
        jLabel4 = new javax.swing.JLabel();
        HMinSlider = new javax.swing.JSlider();
        HMaxSlider = new javax.swing.JSlider();
        jPanel4 = new javax.swing.JPanel();
        jLabel5 = new javax.swing.JLabel();
        SMinSlider = new javax.swing.JSlider();
        SMaxSlider = new javax.swing.JSlider();
        jPanel5 = new javax.swing.JPanel();
        jLabel6 = new javax.swing.JLabel();
        VMinSlider = new javax.swing.JSlider();
        VMaxSlider = new javax.swing.JSlider();
        jPanel6 = new javax.swing.JPanel();
        jLabel7 = new javax.swing.JLabel();
        jSlider7 = new javax.swing.JSlider();

        setLayout(new javax.swing.BoxLayout(this, javax.swing.BoxLayout.Y_AXIS));

        jPanel1.setName("jPanel1"); // NOI18N

        ColorCircleLabel.setText("jLabel1");
        ColorCircleLabel.setMaximumSize(new java.awt.Dimension(300, 300));
        ColorCircleLabel.setMinimumSize(new java.awt.Dimension(300, 300));
        ColorCircleLabel.setName("ColorCircleLabel"); // NOI18N
        ColorCircleLabel.setPreferredSize(new java.awt.Dimension(300, 300));
        jPanel1.add(ColorCircleLabel);

        add(jPanel1);

        jPanel7.setName("jPanel7"); // NOI18N
        jPanel7.setLayout(new java.awt.FlowLayout(java.awt.FlowLayout.LEFT));

        showHistogramCheckBox.setSelected(true);
        showHistogramCheckBox.setText("Show histogram");
        showHistogramCheckBox.setName("showHistogramCheckBox"); // NOI18N
        jPanel7.add(showHistogramCheckBox);

        add(jPanel7);

        jPanel2.setName("jPanel2"); // NOI18N

        jLabel2.setText("Minimum");
        jLabel2.setName("jLabel2"); // NOI18N
        jPanel2.add(jLabel2);

        jLabel3.setText("Maximum");
        jLabel3.setName("jLabel3"); // NOI18N
        jPanel2.add(jLabel3);

        add(jPanel2);

        jPanel3.setName("jPanel3"); // NOI18N

        jLabel4.setText("H");
        jLabel4.setName("jLabel4"); // NOI18N
        jPanel3.add(jLabel4);

        HMinSlider.setMaximum(629);
        HMinSlider.setValue(0);
        HMinSlider.setName("HMinSlider"); // NOI18N
        HMinSlider.setPreferredSize(new java.awt.Dimension(140, 39));
        HMinSlider.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                HMinSliderMouseReleased(evt);
            }
        });
        HMinSlider.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                HMinSliderMouseDragged(evt);
            }
        });
        jPanel3.add(HMinSlider);

        HMaxSlider.setMaximum(629);
        HMaxSlider.setValue(629);
        HMaxSlider.setName("HMaxSlider"); // NOI18N
        HMaxSlider.setPreferredSize(new java.awt.Dimension(140, 39));
        HMaxSlider.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                HMaxSliderMouseReleased(evt);
            }
        });
        HMaxSlider.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                HMaxSliderMouseDragged(evt);
            }
        });
        jPanel3.add(HMaxSlider);

        add(jPanel3);

        jPanel4.setName("jPanel4"); // NOI18N

        jLabel5.setText("S");
        jLabel5.setName("jLabel5"); // NOI18N
        jPanel4.add(jLabel5);

        SMinSlider.setMaximum(255);
        SMinSlider.setValue(0);
        SMinSlider.setName("SMinSlider"); // NOI18N
        SMinSlider.setPreferredSize(new java.awt.Dimension(140, 39));
        SMinSlider.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                SMinSliderMouseReleased(evt);
            }
        });
        SMinSlider.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                SMinSliderMouseDragged(evt);
            }
        });
        jPanel4.add(SMinSlider);

        SMaxSlider.setMaximum(255);
        SMaxSlider.setValue(255);
        SMaxSlider.setName("SMaxSlider"); // NOI18N
        SMaxSlider.setPreferredSize(new java.awt.Dimension(140, 39));
        SMaxSlider.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                SMaxSliderMouseReleased(evt);
            }
        });
        SMaxSlider.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                SMaxSliderMouseDragged(evt);
            }
        });
        jPanel4.add(SMaxSlider);

        add(jPanel4);

        jPanel5.setName("jPanel5"); // NOI18N

        jLabel6.setText("V");
        jLabel6.setName("jLabel6"); // NOI18N
        jPanel5.add(jLabel6);

        VMinSlider.setMaximum(255);
        VMinSlider.setValue(0);
        VMinSlider.setName("VMinSlider"); // NOI18N
        VMinSlider.setPreferredSize(new java.awt.Dimension(140, 39));
        VMinSlider.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                VMinSliderMouseReleased(evt);
            }
        });
        VMinSlider.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                VMinSliderMouseDragged(evt);
            }
        });
        jPanel5.add(VMinSlider);

        VMaxSlider.setMaximum(255);
        VMaxSlider.setValue(255);
        VMaxSlider.setName("VMaxSlider"); // NOI18N
        VMaxSlider.setPreferredSize(new java.awt.Dimension(140, 39));
        VMaxSlider.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseReleased(java.awt.event.MouseEvent evt) {
                VMaxSliderMouseReleased(evt);
            }
        });
        VMaxSlider.addMouseMotionListener(new java.awt.event.MouseMotionAdapter() {
            public void mouseDragged(java.awt.event.MouseEvent evt) {
                VMaxSliderMouseDragged(evt);
            }
        });
        jPanel5.add(VMaxSlider);

        add(jPanel5);

        jPanel6.setName("jPanel6"); // NOI18N

        jLabel7.setText("Threshold");
        jLabel7.setName("jLabel7"); // NOI18N
        jPanel6.add(jLabel7);

        jSlider7.setMaximum(1000);
        jSlider7.setValue(1);
        jSlider7.setEnabled(false);
        jSlider7.setName("jSlider7"); // NOI18N
        jPanel6.add(jSlider7);

        add(jPanel6);
    }// </editor-fold>//GEN-END:initComponents

    private void HMinSliderMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_HMinSliderMouseDragged
        refresh();
    }//GEN-LAST:event_HMinSliderMouseDragged

    private void HMaxSliderMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_HMaxSliderMouseDragged
        refresh();
    }//GEN-LAST:event_HMaxSliderMouseDragged

    private void SMinSliderMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_SMinSliderMouseDragged
        if (SMinSlider.getValue() > SMaxSlider.getValue()) {
            SMaxSlider.setValue(SMinSlider.getValue());
        }
        refresh();
    }//GEN-LAST:event_SMinSliderMouseDragged

    private void SMaxSliderMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_SMaxSliderMouseDragged
        if (SMaxSlider.getValue() < SMinSlider.getValue()) {
            SMinSlider.setValue(SMaxSlider.getValue());
        }
        refresh();
    }//GEN-LAST:event_SMaxSliderMouseDragged

    private void HMinSliderMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_HMinSliderMouseReleased
        refresh();
        fireFilterChangedEvent(new FilterChangedEvent(getHSVFilter(), this));
    }//GEN-LAST:event_HMinSliderMouseReleased

    private void HMaxSliderMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_HMaxSliderMouseReleased
        refresh();
        fireFilterChangedEvent(new FilterChangedEvent(getHSVFilter(), this));
    }//GEN-LAST:event_HMaxSliderMouseReleased

    private void SMinSliderMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_SMinSliderMouseReleased
        refresh();
        fireFilterChangedEvent(new FilterChangedEvent(getHSVFilter(), this));
    }//GEN-LAST:event_SMinSliderMouseReleased

    private void SMaxSliderMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_SMaxSliderMouseReleased
        refresh();
        fireFilterChangedEvent(new FilterChangedEvent(getHSVFilter(), this));
    }//GEN-LAST:event_SMaxSliderMouseReleased

    private void VMinSliderMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_VMinSliderMouseDragged
        if (VMinSlider.getValue() > VMaxSlider.getValue()) {
            VMaxSlider.setValue(VMinSlider.getValue());
        }
        refresh();
    }//GEN-LAST:event_VMinSliderMouseDragged

    private void VMaxSliderMouseDragged(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_VMaxSliderMouseDragged
        if (VMaxSlider.getValue() < VMinSlider.getValue()) {
            VMinSlider.setValue(VMaxSlider.getValue());
        }
        refresh();
    }//GEN-LAST:event_VMaxSliderMouseDragged

    private void VMinSliderMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_VMinSliderMouseReleased
        refresh();
        fireFilterChangedEvent(new FilterChangedEvent(getHSVFilter(), this));
    }//GEN-LAST:event_VMinSliderMouseReleased

    private void VMaxSliderMouseReleased(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_VMaxSliderMouseReleased
        refresh();
        fireFilterChangedEvent(new FilterChangedEvent(getHSVFilter(), this));
    }//GEN-LAST:event_VMaxSliderMouseReleased
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel ColorCircleLabel;
    private javax.swing.JSlider HMaxSlider;
    private javax.swing.JSlider HMinSlider;
    private javax.swing.JSlider SMaxSlider;
    private javax.swing.JSlider SMinSlider;
    private javax.swing.JSlider VMaxSlider;
    private javax.swing.JSlider VMinSlider;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JPanel jPanel4;
    private javax.swing.JPanel jPanel5;
    private javax.swing.JPanel jPanel6;
    private javax.swing.JPanel jPanel7;
    private javax.swing.JSlider jSlider7;
    private javax.swing.JCheckBox showHistogramCheckBox;
    // End of variables declaration//GEN-END:variables

    /**
     * Sets the HSV filter of this panel.
     * @param hsvFilter The HSV filter to become this panel's filter.
     */
    public void setHSVFilter(bica.HSVFilter hsvFilter) {
        HMinSlider.setValue((int) hsvFilter.hmin);
        HMaxSlider.setValue((int) hsvFilter.hmax);
        SMinSlider.setValue((int) hsvFilter.smin * 255 / 100);
        SMaxSlider.setValue((int) hsvFilter.smax * 255 / 100);
        VMinSlider.setValue((int) hsvFilter.vmin / 100);
        VMaxSlider.setValue((int) hsvFilter.vmax / 100);
        refresh();
    }

    /**
     * Gets the HSV filter of this panel.
     * @return
     */
    public bica.HSVFilter getHSVFilter() {
        bica.HSVFilter newFilter = new bica.HSVFilter(HMinSlider.getValue(),
                HMaxSlider.getValue(),
                (SMinSlider.getValue() * 100) / 255,
                (SMaxSlider.getValue() * 100) / 255,
                VMinSlider.getValue() * 100,
                VMaxSlider.getValue() * 100);
        return newFilter;
    }

    /**
     * Sets histogram of an image.
     * @param h Array with h values.
     * @param s Array with S values.
     * @param v Array with V values.
     */
    public void setHistogram(double h[], double s[], double v[]) {
        histogramH = h;
        histogramS = s;
        histogramV = v;
        refresh();
    }

    /**
     * Draws a red square in the HSV value specified.
     * @param h H value.
     * @param s S value.
     * @param v V value.
     */
    public void drawRedSquareInHSVValue(double h, double s, double v) {

        byte[] circleCopy = drawHsvMap();
        drawHistogram(circleCopy);
        drawCheese(circleCopy);
        draw(circleCopy);

        double radio_hsi_map = imageWidth / 2;
        double x_centro = imageWidth / 2;
        double y_centro = imageWidth / 2;

        // Calcular los valores de h y de s
        double hvalue = (h / 360.0) * (2.0 * Math.PI * 100.0);
        double svalue = s * 255.0;

        // Normalizar el valor de h y de s
        double hc = (hvalue / (double) HMinSlider.getMaximum()) * Math.PI * 2.0;
        double sc = (svalue / (double) SMaxSlider.getMaximum()) * radio_hsi_map;

        // Calcular punto del circulo
        int x1, y1;
        x1 = (int) (Math.cos(hc) * sc + x_centro);
        y1 = (int) (y_centro - Math.sin(hc) * sc);

        // Pintar cuadrado rojo en x1,y1
        int side = 4;
        for (int i = (x1 - side / 2); i < (x1 + side / 2); i++) {
            for (int j = (y1 - side / 2); j < (y1 + side / 2); j++) {
                int r = 255, g = 0, b = 0;
                circleCopy[(j * imageWidth + i) * 3] = (byte) b;
                circleCopy[(j * imageWidth + i) * 3 + 1] = (byte) g;
                circleCopy[(j * imageWidth + i) * 3 + 2] = (byte) r;
            }
        }
    }

    /**
     * Adds the specified filter changed listener to receive key events from
     * this component.
     * @param listener The filter changed listener
     */
    public void addHSVFilterChangedListener(FilterChangedListener listener) {
        listenerList.add(FilterChangedListener.class, listener);
    }

    /**
     * Removes the specified filter changed event so that it no longer receives
     * filter changed events from this component.
     * @param listener The filter changed listener
     */
    public void removeHSVFilterChangedListener(FilterChangedListener listener) {
        listenerList.remove(FilterChangedListener.class, listener);
    }

    /* PRIVATE METHODS */
    /**
     * Fire and notify a FilterChangedEvent
     * @param evt The event to be fired
     */
    private void fireFilterChangedEvent(FilterChangedEvent evt) {
        Object[] listeners = listenerList.getListenerList();
        // Each listener occupies two elements - the first is the listener class
        // and the second is the listener instance
        for (int i = 0; i < listeners.length; i += 2) {
            if (listeners[i] == FilterChangedListener.class) {
                ((FilterChangedListener) listeners[i + 1]).filterChanged(evt);
            }
        }
    }

    /**
     * Helper method. Refresh the HSVMap.
     */
    private void refresh() {
        byte[] circleCopy = drawHsvMap();
        drawHistogram(circleCopy);
        drawCheese(circleCopy);
        draw(circleCopy);
    }

    /**
     * Helper method. Draw the HSV map. It is only created the first time the
     * method is called, the next calls returns the value saved in the attribute
     * circle.
     * @return Copy of a HSV map.
     */
    private byte[] drawHsvMap() {

        // Do nothing if "circle" is already initialize
        if (circle != null) {
            return circle.clone();
        }

        // Init "circle"
        circle = new byte[imageWidth * imageHeight * imageChannels];

        int i, j, ind;
        double x, y, H, S, scale;
        double r, g, b;
        byte R, G, B;

        for (j = 0; j < imageHeight; j++) {
            for (i = 0; i < imageWidth; i++) {
                x = (2.0 * i) / imageWidth - 1.0;
                y = 1.0 - (2.0 * j) / imageWidth;
                H = Math.atan2(y, x);
                if (H >= 2 * Math.PI) {
                    H -= 2 * Math.PI;
                }
                if (H < 0) {
                    H += 2 * Math.PI;
                }
                H = Math.toDegrees(H);
                S = Math.sqrt(y * y + x * x);

                if (S < 1.) {
                    double[] rgb = hsv2rgb(H, S, 0.8);
                    r = rgb[0];
                    g = rgb[1];
                    b = rgb[2];

                    scale = 255.0;
                    R = (byte) (scale * r);
                    G = (byte) (scale * g);
                    B = (byte) (scale * b);
                } else {
                    R = (byte) 175;
                    G = (byte) 175;
                    B = (byte) 175;
                }

                ind = (imageWidth * j + i) * 3;
                circle[ind] = B; /* Blue */
                circle[ind + 1] = G; /* Green */
                circle[ind + 2] = R; /* Red */
            }
        }

        return circle.clone();
    }

    /**
     * Helper method. Convert HSV to RGB.
     * @param H H value.
     * @param S S value.
     * @param V V value.
     * @return  Array with RGB value. Position 0 is red, position 1 is green and
     * position B is blue.
     */
    private double[] hsv2rgb(double H, double S, double V) {
        /* From the wikipedia: hsv color space */
        /*H entre 0 y 360, S entre 0 y 1 , V entre 0 y 255*/

        double[] rgb = new double[3];
        double r = 0, g = 0, b = 0;
        double h_aux, f, p, q, t, v_aux;

        h_aux = ((int) Math.abs(H / 60.0)) % 6;
        f = (H / 60.0) - h_aux;

        v_aux = V;
        p = v_aux * (1 - S);
        q = v_aux * (1 - f * S);
        t = v_aux * (1 - (1 - f) * S);

        if (((int) h_aux) == 0) {
            r = v_aux;
            g = t;
            b = p;
        } else if (((int) h_aux == 1)) {
            r = q;
            g = v_aux;
            b = p;
        } else if (((int) h_aux == 2)) {
            r = p;
            g = v_aux;
            b = t;
        } else if (((int) h_aux == 3)) {
            r = p;
            g = q;
            b = v_aux;
        } else if (((int) h_aux == 4)) {
            r = t;
            g = p;
            b = v_aux;
        } else if (((int) h_aux == 5)) {
            r = v_aux;
            g = p;
            b = q;
        }

        rgb[0] = r;
        rgb[1] = g;
        rgb[2] = b;
        return rgb;
    }

    /**
     * Helper method. Draws histogram of an image.
     * @param circleCopy A byte array representing the HSV map.
     */
    private void drawHistogram(byte[] circleCopy) {

        if (!showHistogramCheckBox.isSelected()) {
            return;
        }

        // Security check
        if ((histogramH.length != histogramS.length) && (histogramS.length != histogramV.length)) {
            return;
        }

        double radio_hsi_map = imageWidth / 2;
        double x_centro = imageWidth / 2;
        double y_centro = imageWidth / 2;

        for (int i = 0; i < histogramH.length; i++) {
            // Calcular los valores de h y de s
            double hvalue = (histogramH[i] / 360.0) * (2.0 * Math.PI * 100.0);
            double svalue = histogramS[i] * 255.0;

            // Normalizar el valor de h y de s
            double hc = (hvalue / (double) HMinSlider.getMaximum()) * Math.PI * 2.0;
            double sc = (svalue / (double) SMaxSlider.getMaximum()) * radio_hsi_map;

            // Calcular punto del circulo
            int x1, y1;
            x1 = (int) (Math.cos(hc) * sc + x_centro);
            y1 = (int) (y_centro - Math.sin(hc) * sc);

            int r = 255, g = 255, b = 255;
            circleCopy[(y1 * imageWidth + x1) * 3] = (byte) b;
            circleCopy[(y1 * imageWidth + x1) * 3 + 1] = (byte) g;
            circleCopy[(y1 * imageWidth + x1) * 3 + 2] = (byte) r;
        }
    }

    /**
     * Helper method. Draw a cheese portion following the max and min values of
     * H & S.
     * @param circleCopy A byte array representing the HSV map.
     */
    private void drawCheese(byte[] circleCopy) {

        double radio_hsi_map = imageWidth / 2;
        double x_centro = imageWidth / 2;
        double y_centro = imageHeight / 2;

        double h_min = ((double) HMinSlider.getValue() / (double) HMinSlider.getMaximum()) * Math.PI * 2.0;
        double h_max = ((double) HMaxSlider.getValue() / (double) HMaxSlider.getMaximum()) * Math.PI * 2.0;
        double s_min = ((double) SMinSlider.getValue() / (double) SMinSlider.getMaximum()) * radio_hsi_map;
        double s_max = ((double) SMaxSlider.getValue() / (double) SMaxSlider.getMaximum()) * radio_hsi_map;


        int x1, y1, x2, y2;


        x1 = (int) (Math.cos(h_max) * s_min + x_centro);
        y1 = (int) (y_centro - Math.sin(h_max) * s_min);
        x2 = (int) (Math.cos(h_max) * s_max + x_centro);
        y2 = (int) (y_centro - Math.sin(h_max) * s_max);


        lineinimage(x1, y1, x2, y2, circleCopy);


        x1 = (int) (Math.cos(h_min) * s_min + x_centro);
        y1 = (int) (y_centro - Math.sin(h_min) * s_min);
        x2 = (int) (Math.cos(h_min) * s_max + x_centro);
        y2 = (int) (y_centro - Math.sin(h_min) * s_max);


        lineinimage(x1, y1, x2, y2, circleCopy);

        x1 = (int) (Math.cos(h_min) * s_max + x_centro);
        y1 = (int) (y_centro - Math.sin(h_min) * s_max);
        x2 = (int) (Math.cos(h_max) * s_max + x_centro);
        y2 = (int) (y_centro - Math.sin(h_max) * s_max);


        drawarc((int) x_centro, (int) y_centro, (int) s_max, x1, y1, x2, y2, circleCopy);

        x1 = (int) (Math.cos(h_min) * s_min + x_centro);
        y1 = (int) (y_centro - Math.sin(h_min) * s_min);
        x2 = (int) (Math.cos(h_max) * s_min + x_centro);
        y2 = (int) (y_centro - Math.sin(h_max) * s_min);


        drawarc((int) x_centro, (int) y_centro, (int) s_min, x1, y1, x2, y2, circleCopy);

    }

    /**
     * Helper method. Draw a line in a HSV map.
     * @param xa X coordinate of point A.
     * @param ya Y coordinate of point A.
     * @param xb X coordinate of point B.
     * @param yb Y coordinate of point B.
     * @param circleCopy The HSV map.
     */
    private void lineinimage(int xa, int ya, int xb, int yb, byte[] circleCopy) {
        float L;
        int i, imax, r, g, b;
        int lastx, lasty, thisx, thisy, lastcount;
        int threshold = 1;
        int Xmax, Xmin, Ymax, Ymin;

        Xmin = 0;
        Xmax = imageWidth - 1;
        Ymin = 0;
        Ymax = imageWidth - 1;

        r = 0;
        g = 0;
        b = 0;
        /* first, check both points are inside the limits and draw them */
        if ((xa >= Xmin) && (xa < Xmax + 1) && (ya >= Ymin) && (ya < Ymax + 1)
                && (xb >= Xmin) && (xb < Xmax + 1) && (yb >= Ymin) && (yb < Ymax + 1)) {
            /* draw both points */

            int SMAX = imageWidth;

            circleCopy[(SMAX * ya + xa) * 3 + 0] = (byte) b;
            circleCopy[(SMAX * ya + xa) * 3 + 1] = (byte) g;
            circleCopy[(SMAX * ya + xa) * 3 + 2] = (byte) r;
            circleCopy[(SMAX * yb + xb) * 3 + 0] = (byte) b;
            circleCopy[(SMAX * yb + xb) * 3 + 1] = (byte) g;
            circleCopy[(SMAX * yb + xb) * 3 + 2] = (byte) r;

            L = (float) Math.sqrt((double) ((xb - xa) * (xb - xa) + (yb - ya) * (yb - ya)));
            imax = 3 * (int) L + 1;
            /* if (debug==1) printf("xa=%d ya=%d xb=%d yb=%d L=%.f imax=%d\n",xa,ya,xb,yb,L,imax);  */
            lastx = xa;
            lasty = xb;
            lastcount = 0;
            for (i = 0; i <= imax; i++) {
                thisy = (int) ((float) ya + (float) i / (float) imax * (float) (yb - ya));
                thisx = (int) ((float) xa + (float) i / (float) imax * (float) (xb - xa));
                if ((thisy == lasty) && (thisx == lastx)) {
                    lastcount++;
                } else {
                    if (lastcount >= threshold) { /* draw that point in the image */
                        circleCopy[(SMAX * lasty + lastx) * 3 + 0] = (byte) b;
                        circleCopy[(SMAX * lasty + lastx) * 3 + 1] = (byte) g;
                        circleCopy[(SMAX * lasty + lastx) * 3 + 2] = (byte) r;
                    }
                    lasty = thisy;
                    lastx = thisx;
                    lastcount = 0;
                }
            }

        }

    }

    /**
     * Helper method. Draw an arc in a HSV map.
     * @param xcentro X coordinate of the circle center.
     * @param ycentro Y coordinate of the circle center.
     * @param radio Radio of the circle.
     * @param x1 X coordinate of the firt point.
     * @param y1 Y coordinate of the firt point.
     * @param x2 X coordinate of the second point.
     * @param y2 Y coordinate of the second point.
     * @param circleCopy The HSV map.
     */
    private void drawarc(int xcentro, int ycentro, int radio, int x1, int y1, int x2, int y2, byte[] circleCopy) {

        int r, g, b;
        int x, y;
        float i, imax;

        /* In this image always graf coordinates x=horizontal, y=vertical, starting at the top left corner of the image. They can't reach 240 or 320, their are not valid values for the pixels.  */
        if ((x1 == x2) && (y1 == y2)) {
            drawcircle(xcentro, ycentro, radio, circleCopy);

        } else {
            r = 0;
            g = 0;
            b = 0;
            x1 = x1 - xcentro;
            y1 = ycentro - y1;
            x2 = x2 - xcentro;
            y2 = ycentro - y2;

            if (x1 == 0) {
                if (y1 < 0) {
                    i = (float) (3.f * Math.PI / 2.f);
                } else {
                    i = (float) (Math.PI / 2.f);
                }
            } else {
                if (y1 == 0) {
                    if (x1 < 0) {
                        i = (float) Math.PI;
                    } else {
                        i = 0.f;
                    }
                } else {
                    if (x1 > 0) {
                        i = (float) Math.atan((float) y1 / (float) x1);
                    } else {
                        i = (float) (Math.atan((float) y1 / (float) x1) + Math.PI);
                    }
                }
            }

            i = (float) Math.toDegrees(i);

            if (x2 == 0) {
                if (y2 < 0) {
                    imax = (float) (3 * Math.PI / 2.);
                } else {
                    imax = (float) (Math.PI / 2.);
                }
            } else {
                if (y2 == 0) {
                    if (x2 < 0) {
                        imax = (float) Math.PI;
                    } else {
                        imax = (float) 0.;
                    }
                } else {
                    if (x2 > 0) {
                        imax = (float) Math.atan((float) y2 / (float) x2);
                    } else {
                        imax = (float) (Math.atan((float) y2 / (float) x2) + Math.PI);
                    }
                }
            }
            imax = (float) Math.toDegrees(imax);
            if (imax < i) {
                imax = imax + 360.0f;
            }
            for (; i <= imax; i = i + 0.1f) {
                x = (int) (Math.cos(Math.toRadians((double) i)) * radio + (double) xcentro);
                y = (int) ((double) ycentro - Math.sin(Math.toRadians((double) i)) * (double) radio);

                int SMAX = imageWidth;

                circleCopy[(y * SMAX + x) * 3] = (byte) b;
                circleCopy[(y * SMAX + x) * 3 + 1] = (byte) g;
                circleCopy[(y * SMAX + x) * 3 + 2] = (byte) r;
            }
        }

    }

    /**
     * Helper method. Draw a circle in a HSV map.
     * @param xcentro X coordinate of the circle center.
     * @param ycentro Y coordinate of the circle center.
     * @param radio Radio of the circle.
     * @param circleCopy The HSV map.
     */
    private void drawcircle(int xcentro, int ycentro, int radio, byte[] circleCopy) {

        int r, g, b;
        int x1, y1;
        float i;

        /* In this image always graf coordinates x=horizontal, y=vertical, starting at the top left corner of the image. They can't reach 240 or 320, their are not valid values for the pixels.  */

        r = 113;
        g = 198;
        b = 113;

        for (i = 0.f; i <= 360; i = i + 0.1f) {
            x1 = (int) (Math.cos(Math.toRadians(i)) * (double) radio + xcentro);
            y1 = (int) (Math.sin(Math.toRadians(i)) * (double) radio + ycentro);

            circleCopy[(y1 * imageHeight + x1) * 3] = (byte) b;
            circleCopy[(y1 * imageHeight + x1) * 3 + 1] = (byte) g;
            circleCopy[(y1 * imageHeight + x1) * 3 + 2] = (byte) r;
        }

    }

    /**
     * Put a HSV map as an icon in a label.
     * @param circleCopy The HSV map.
     */
    private void draw(byte[] circleCopy) {
        //Paint circle
        int[] bandOffsets = {2, 1, 0}; //r, g, b
        int scanlineStride = imageChannels * imageWidth; //no extra padding
        DataBuffer buffer = new DataBufferByte(circleCopy, imageWidth * imageHeight);
        WritableRaster raster = Raster.createInterleavedRaster(buffer, imageWidth, imageHeight, scanlineStride, imageChannels, bandOffsets, null);

        ColorSpace colorSpace = ColorSpace.getInstance(ColorSpace.CS_LINEAR_RGB);
        boolean hasAlpha = false;
        boolean isAlphaPremultiplied = false;
        int transparency = Transparency.OPAQUE;
        int transferType = DataBuffer.TYPE_BYTE;
        ColorModel colorModel = new ComponentColorModel(colorSpace, hasAlpha, isAlphaPremultiplied, transparency, transferType);

        BufferedImage img = new BufferedImage(colorModel, raster, isAlphaPremultiplied, null);

        //Display image to the label
        ImageIcon icon = new ImageIcon(img);
        ColorCircleLabel.setIcon(icon);
    }

    /**
     * Event which indicates a filter has changed.
     */
    public class FilterChangedEvent extends EventObject {

        private bica.HSVFilter filter;

        /**
         * Constructor
         * @param filter HSVFilter of the class
         * @param source Object source of the event
         */
        public FilterChangedEvent(bica.HSVFilter filter, Object source) {
            super(source);
            this.filter = filter;
        }

        /**
         * Filter getter
         * @return The filter of the event
         */
        public bica.HSVFilter getFilter() {
            return filter;
        }
    }

    /**
     * The listener interface for receiving filter changed events.
     */
    public interface FilterChangedListener extends EventListener {

        /**
         * Invoked when the filter change
         * @param evt The new filter
         */
        public void filterChanged(FilterChangedEvent evt);
    }
}
